eval("(function() {\n\n// Standard JUI date picker component\n// Usage: {{date-picker value=[date value to bind to your controller]}}\nApp.DatePickerComponent = Ember.Component.extend({\n    attributeBindings: ['includeToday', 'disabled'],\n    layoutName: 'components/datepicker',\n    didInsertElement: function() {\n\n        var self = this\n            , dateValue = this.get('value')\n            , disabled = this.get('disabled')\n            , currentDate = moment()\n            , includeToday = this.get('includeToday')\n            , $element = this.$()\n            , $datepicker = $element.find('.datepicker')\n            , $input = $element.find('input')\n            , locale = typeof localeString === 'undefined' ? 'YYYY-MM-DD' : localeString;\n\n        $datepicker.datepicker({\n                format: locale.toLowerCase(),\n                onRender: function(date) {\n                    if (disabled === true) {\n                        return 'disabled';\n\n                    } else {\n                        if (includeToday === true) \n                            return date.valueOf() < moment(currentDate).subtract('days', 1).valueOf() ? 'disabled' : '';\n                    }\n                }\n            })\n            .on('changeDate', function(event) {\n                self.set('value', moment(event.date).format('YYYY-MM-DD'));\n                $input.val(moment(event.date).format(locale));\n               \n                $datepicker.datepicker('hide');\n            });\n            // .datepicker('setValue', moment(dateValue).toDate());\n\n        if (!Ember.isNone(dateValue)) {\n            $input.val(moment(dateValue).format(locale));\n            $datepicker.datepicker('setValue', moment(dateValue).toDate());\n        }\n    }\n});\n\n// Salesforce Rich Text Editor component\n// Usage: In the body tag of the VF page you are editing, insert an apex rich text tag inside a div with id 'richTextForm'\n// then in your template: {{rich-text componentId=[this elements id if you need it] value=[rich text to bind to your controller]}}\n// Attributes:\n// componentId - This is the Id of the element you have created, can be useful if you need to jQuery for it.\n// bindingType - You can specify the component to bind its 'value' property to the 'html' or 'text' content of the rich text field.\n//               If unspecified, it will not bind at all.\n// autofocus - Whether the cursor should autofocus on the component when it is added to the DOM.\nApp.RichTextComponent = Ember.Component.extend({\n    attributeBindings: ['componentId', 'bindingType', 'autofocus', 'height'],\n    previousContent: '',\n    didInsertElement: function() {\n        var self = this\n            , richTextForm= $('#richTextForm')\n            , value = this.get('value')\n            , bindingType = this.get('bindingType')\n            , autofocus = this.get('autofocus')\n            , height = this.get('height')\n            , pollCounter = 0; // We should set a max amount of polling incase the component launches but the user switches the view right away.\n\n        richTextForm.find('.cke').remove();\n        this.$().append(richTextForm.html());\n        this.set('componentId', this.get('elementId'));\n\n        // We have to constantly poll for Salesforce to finish rendering the rich text field before updating its value.\n        var pollForRTF = setInterval(function(){ \n            pollCounter++;\n\n            if (pollCounter > 50) {\n                clearInterval(pollForRTF);\n            }\n\n            if (!Ember.isEmpty(self.$())) { // A little more checking in case user navigates to another view right away\n                var rtfField = self.$().find('iframe').contents();\n\n                if (rtfField.length > 0 && rtfField.find('body').length > 0) {\n                    clearInterval(pollForRTF);\n                    \n                    // This run later and re-finding of the body is a mod to make the RTF values populate in Firefox\n                    Ember.run.later(this, function() {\n                        if (!Ember.isEmpty(self.$())) { // A little more checking in case user navigates to another view right away\n                        \n                            var rtfBody = self.$().find('iframe').contents().find('body');\n                            if (autofocus === true) {\n                                rtfBody.focus();\n                            }\n\n                            if (!Ember.isNone(value)) {\n                                rtfBody.html(value);\n                            }\n                            \n                            if (!Ember.isNone(height)) {\n                                self.$().find('.cke_contents').height(height);\n                            }\n\n                            if (bindingType === 'html') {\n                                rtfBody.keyup(function(e) {\n                                    var richText = $(e.target);\n\n                                    richText.find('[style]').removeAttr('style');\n                                    richText.find('[class]').removeAttr('class');\n\n                                    var currentContent = richText.html();\n                                    var previousContent = self.get('previousContent');\n\n                                    self.set('value', currentContent);\n                                    self.set('previousContent', currentContent);\n                                });\n                            } else if (bindingType === 'text') {\n                                rtfBody.keyup(function(e) {\n                                    var richText = $(e.target);\n\n                                    richText.find('[style]').removeAttr('style');\n                                    richText.find('[class]').removeAttr('class');\n\n                                    var currentContent = richText.html();\n                                    var previousContent = self.get('previousContent');\n\n                                    self.set('value', e.target.textContent);\n                                    self.set('previousContent', currentContent);\n                                });\n                            }\n                        }\n                    }, 300);\n                }\n            }\n        }, 300);\n    }\n});\n\n})();//@ sourceURL=js/emberComponents.js")

eval("(function() {\n\n// This function takes a number and adds commas for every hundredth value.\nfunction ReplaceNumberWithCommas(yourNumber) {\n    //Seperates the components of the number\n    var n= yourNumber.toString().split(\".\");\n    //Comma-fies the first part\n    n[0] = n[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n    //Combines the two sections\n    return n.join(\".\");\n}\n\nfunction parseResult(result) {\n    return JSON.parse($('<div>').html(result).text());\n}\n\n/*\n\tgetDepndentOptions will make a describe call to SF and return an object with the fields the dependent picklist\n\tis dependent on. The function needs the VF page to have the following scripts to work\n\n\t<apex:includeScript value=\"/soap/ajax/30.0/connection.js\"/>\n\t<apex:includeScript value=\"/soap/ajax/30.0/apex.js\"/>\n*/\n\nfunction getDependentOptions (apiKey, objName, ctrlFieldName, depFieldName, namespace) {\n\tsforce.connection.sessionId = apiKey\n    if(namespace){\n        objName = namespace + objName;\n        ctrlFieldName = namespace + ctrlFieldName;\n        depFieldName = namespace + depFieldName;\n    }\n\n    // Isolate the Describe info for the relevant fields\n    var objDesc = sforce.connection.describeSObject(objName);\n    var ctrlFieldDesc, depFieldDesc;\n    var found = 0;\n    for (var i=0; i<objDesc.fields.length; i++) {\n        var f = objDesc.fields[i];\n        if (f.name == ctrlFieldName) {\n            ctrlFieldDesc = f;\n            found++;\n        } else if (f.name == depFieldName) {\n            depFieldDesc = f;\n            found++;\n        }\n        if (found==2) break; \n    }\n \n    // Set up return object\n    var dependentOptions = {};\n\n    var ctrlValues = ctrlFieldDesc.picklistValues;\n    for (var i=0; i<ctrlValues.length; i++) {\n        dependentOptions[ctrlValues[i].label] = [];\n    }\n \n    var base64 = new sforce.Base64Binary(\"\");\n    function testBit (validFor, pos) {\n        var byteToCheck = Math.floor(pos/8);\n        var bit = 7 - (pos % 8);\n        return ((Math.pow(2, bit) & validFor.charCodeAt(byteToCheck)) >> bit) == 1;\n    }\n    \n    // For each dependent value, check whether it is valid for each controlling value\n    var depValues = depFieldDesc.picklistValues;\n    for (var i=0; i<depValues.length; i++) {\n        var thisOption = depValues[i];\n        var validForDec = base64.decode(thisOption.validFor);\n        for (var ctrlValue=0; ctrlValue<ctrlValues.length; ctrlValue++) {\n            if (testBit(validForDec, ctrlValue)) {\n                dependentOptions[ctrlValues[ctrlValue].label].push(thisOption.label);\n            }\n        }\n    }\n    return dependentOptions;\n}\n\n})();//@ sourceURL=js/toHelpers.js")

eval("(function() {\n\nApp.SectionCheck = Ember.Mixin.create({\n    isOnJobSpecific: function() {\n        return isOnJobSpecific;\n    }.property()\n});\n\nApp.FormBuilderMixin = Ember.Mixin.create({\n    elementTypes: ['Question', 'Heading', 'Rich Text'],\n    answerTypes: ['Radio Buttons', 'Checkboxes', 'Text Field', 'Paragraph', 'Date'],\n    deletedFormElements: [],\n    deletedAnswerChoices: [],\n    jobTitle: function() {\n        return requisitionJobTitle;\n    }.property(),\n    hasFormElements: function() {\n        return this.get('formElements').length > 1;\n    }.property('formElements'),\n    disableCancel: function() {\n        return this.get('formElements').isAny('isEditing') === true ? 'disabled' : false;\n    }.property('formElements.@each.isEditing'),\n    disableSave: function() {\n        var elements = this.get('formElements')\n            , doesNotHaveFormElements = elements.length === 1 || (elements.length === 2 && elements[1].isNew === true)\n            , isSaving = this.get('isSaving')\n            , isEditing = elements.isAny('isEditing');\n\n        return doesNotHaveFormElements === true || isSaving === true || isEditing === true ? 'disabled' : false; \n    }.property('formElements', 'formElements.@each.isNew', 'isSaving', 'formElements.@each.isEditing'),\n    doesNotHaveFormElements: function() {\n        var elements = this.get('formElements');\n        return elements.length === 1 || (elements.length === 2 && elements[1].isNew === true);\n    }.property('formElements', 'formElements.@each.isNew'),\n    actions: {\n        clickCancel: function() {\n            this.goBackToOrigin();\n        },\n        clickSaveAndClose: function() {\n            this.saveFormElements()\n                .then(this.goBackToOrigin)\n                .then(undefined, this.handleError);\n        },\n        clickSaveAndKeepWorking: function() {\n            var currentPath = this.get('currentPath');\n            // Only perform save if we aren't already saving.\n            // This occurs mostly in the configurator because a user can switch sections quickly.\n            if (this.get('isSaving') !== true) {    \n                this.set('showSavingNotification', true);\n\n                if (currentPath === 'formBuilder.formElements' || Ember.isNone(currentPath)) { \n                    this.saveFormElements()\n                        .then(this.updateObjectsAndKeepWorking)\n                        .then(undefined, this.handleError);\n                } else if (currentPath === 'formBuilder.applicationSection') {\n                    var hiringModel = App.Fixtures.get('currentHiringModel');\n                    console.log(hiringModel)\n                    this.send('saveHiringModelData', hiringModel);\n                } else if (currentPath === 'formBuilder.contactInfo') {\n                    var hiringModel = App.Fixtures.get('currentHiringModel');\n\n                    this.send('saveContactInfo', hiringModel);\n                }\n\n            }   \n        },\n        clickSaveAndPreview: function() {\n            this.saveFormElements()\n                .then(function(self) {\n                    return new Ember.RSVP.Promise(function(resolve, reject) {\n                        if (isSF1 !== true) { \n                            self.set('previewWindow', window.open());\n                        }\n                        resolve(self);\n                    });\n                })\n                .then(this.gotoPreview)\n                .then(undefined, this.handleError);\n        },\n        gotoSection: function(section) {\n            this.set('currentSection', section);\n        }\n    },\n    saveFormElements: function() {\n        var self = this;\n\n        this.set('isSaving', true);\n        \n        var formElementsWithAnswers = [];\n\n        this.get('formElements').forEach(function(fe) { \n            var elementType = fe.get('Element_Type__c')\n                , answerType = fe.get('Answer_Type__c');\n\n            if (elementType === 'Question' && (answerType === 'Radio Buttons' || answerType === 'Checkboxes')) {\n                fe.get('answers').forEach(function(a, i) {\n                    a.set('Sequence_Number__c', i + 1);\n                });\n                formElementsWithAnswers.push(fe);\n            };\n        });\n        \n        var saveObj = {\n            deletedFormElements: this.get('deletedFormElements'),\n            deletedAnswerChoices: this.get('deletedAnswerChoices'),\n            formElements: this.get('formElements').rejectBy('isLast', true),\n            answerChoices: [].concat.apply([], formElementsWithAnswers.getEach('answers').compact())\n        };\n        \n        if (isOnJobSpecific === true) {\n            saveObj.requisitionId = requisitionId;\n            saveObj.allowCandidatesToAssertSkills = this.get('allowCandidatesToAssertSkills');\n        }\n\n        return new Ember.RSVP.Promise(function(resolve, reject) {\n            cont.saveFormElementsJson(JSON.stringify(saveObj), function(res, resObj) {\n                if (res) {\n                    var parsedResult = parseResult(res);\n\n                    if (!Ember.isEmpty(parsedResult.errorMessages)) {\n                        self.set('error', parsedResult.errorMessages[0]);\n                        reject(self);\n                    } else {\n                        self.set('ajaxResult', parsedResult);\n                        resolve(self);\n                    }\n                } else {\n                    self.set('error', resObj.message);\n                    reject(self);\n                }\n            });\n        });\n    },\n    handleError: function(self) {\n        console.log(self.get('error'));\n        var previewWindow = self.get('previewWindow');\n\n        if (!Ember.isNone(previewWindow)) {\n            previewWindow.close();\n        }\n        self.setProperties({\n            errorMessage: self.get('error'),\n        });\n\n        $(window).scrollTop(0);\n    },\n    goBackToOrigin: function(self) {\n        var target = isOnJobSpecific === true ? requisitionId : listViewPrefix;\n\n        if (isSF1 === true && isOnJobSpecific === true) {\n            sforce.one.navigateToSObject(target);\n        } else {\n            window.location.href = '/' + target;\n        }\n    },\n    gotoPreview: function(self) {\n        if (isSF1 === true) {\n            sforce.one.navigateToUrl('/apex/to_applicationFormPreview?id=' + requisitionId);\n        } else {\n            var previewWindow = self.get('previewWindow');\n            var jobOfferPreviewUrl;\n\n            if (typeof requisitionId !== 'undefined' && !Ember.isEmpty(requisitionId)) {\n                jobOfferPreviewUrl = window.location.protocol + '//' + window.location.host + '/apex/to_applicationFormPreview?id=' + requisitionId;\n            } else {\n                jobOfferPreviewUrl = window.location.protocol + '//' + window.location.host + '/apex/to_applicationFormPreview';                \n            }\n            \n            previewWindow.location = jobOfferPreviewUrl;\n            self.set('isSaving', false);\n        }\n    },\n    updateObjectsAndKeepWorking: function(self) {\n        var eIdsMap = self.get('ajaxResult').data.eIdsMap;\n        self.get('formElements').rejectBy('isLast', true).forEach(function(fe) {\n            var elementType = fe.get('Element_Type__c');\n            var answerType = fe.get('Answer_Type__c');\n\n            if (Ember.isEmpty(fe.get('Id'))) {\n                fe.set('Id', eIdsMap.formElements[fe.get('eId')].Id);\n            }\n\n            if (elementType === 'Question' && (answerType === 'Radio Buttons' || answerType === 'Checkboxes')) {\n                fe.get('answers').forEach(function(a) {\n                    a.setProperties({\n                        Id: eIdsMap.answerChoices[a.get('eId')].Id,\n                        Form_Element__c: fe.get('Id')\n                    });\n                });\n            }\n        });\n\n        Ember.run.later(this, function() {\n            self.setProperties({\n                showSavingNotification: false,\n                isSaving: false\n            })\n        }, 1500);\n    }\n});\n\nApp.FormElementsMixin = Ember.Mixin.create({\n    needs: ['formBuilder'],\n    currentSectionBinding: 'controllers.formBuilder.currentSection',\n    sortAscending: true,\n    isInEditMode: function() {\n        return this.isAny('isEditing', true);\n    }.property('@each.isEditing'),\n    hasFormElements: function() {\n        return this.get('model').length > 1;\n    }.property('[]'),\n    actions: {\n        swapFormElements: function(sequenceNumber1, sequenceNumber2) {\n            var formElements = this.get('model')\n                , sequenceProperty = 'Sequence_Number__c'\n                , formElement1 = formElements.findBy(sequenceProperty, sequenceNumber1)\n                , formElement2 = formElements.findBy(sequenceProperty, sequenceNumber2);\n\n            if (!Ember.isNone(formElement1) && !Ember.isNone(formElement2)\n                    && formElement1.get('isLast') !== true && formElement2.get('isLast') !== true) {\n                formElement1.set(sequenceProperty, sequenceNumber2);\n                formElement2.set(sequenceProperty, sequenceNumber1);\n            }\n        }\n    }\n});\n\nApp.FormElementMixin = Ember.Mixin.create({\n    needs: ['formBuilder'],\n    isInEditModeBinding: 'parentController.isInEditMode',\n    elementTypesBinding: 'controllers.formBuilder.elementTypes',\n    answerTypesBinding: 'controllers.formBuilder.answerTypes',\n    formElementsBinding: 'controllers.formBuilder.formElements',\n    currentSectionBinding: 'controllers.formBuilder.currentSection',\n    isQuestionType: Ember.computed.equal('Element_Type__c', 'Question'),\n    answersToDelete: [],\n    maxRichTextLength: 6000,\n    isAtMaxElements: function() {\n        return this.get('parentController.model').length >= 101;\n    }.property('parentController.[]'),\n    previewTemplate: function() {\n        var elementType = this.get('Element_Type__c')\n            , answerType = this.get('Answer_Type__c')\n            , previewTemplate = elementType === 'Question' ? 'preview-' + answerType : 'preview-' + elementType;\n        return previewTemplate.camelize();\n    }.property('Element_Type__c', 'Answer_Type__c'),\n    editTemplate: function() {\n        var editTemplate = 'edit-'\n            , elementType = this.get('Element_Type__c')\n            , answerType = this.get('Answer_Type__c');\n\n        if (!Ember.isNone(elementType)) {\n            if (elementType === 'Question') {\n                if (Ember.isNone(answerType)) {\n                    answerType = 'Radio Buttons',\n                    this.set('Answer_Type__c', 'Radio Buttons');\n                }\n                editTemplate += answerType;\n                return editTemplate.camelize();\n\n            } else if (elementType !== 'Question') {\n                editTemplate += elementType;\n                return editTemplate.camelize();\n            }\n        }\n    }.property('Element_Type__c', 'Answer_Type__c'),\n    divId: function() {\n        return 'formElement' + this.get('eId');\n    }.property('eId'),\n    doesNotHaveEnoughInfo: function() {\n        var Text__c = this.get('Text__c')\n            , populatedAnswers = this.get('answers').filter(function(a) { return !Ember.isEmpty(a.Value__c); })\n            , Element_Type__c = this.get('Element_Type__c')\n            , Answer_Type__c = this.get('Answer_Type__c')\n            , Rich_Text_Content__c = this.get('Rich_Text_Content__c');\n\n        return (Element_Type__c !== 'Rich Text' && Ember.isEmpty(Text__c)) \n                    || (Element_Type__c === 'Rich Text' && Ember.isEmpty(Rich_Text_Content__c)) \n                    || ((Element_Type__c === 'Question' && (Answer_Type__c === 'Radio Buttons' || Answer_Type__c === 'Checkboxes')) \n                            && Ember.isEmpty(populatedAnswers));\n    }.property('Rich_Text_Content__c', 'Text__c', 'answers', 'Element_Type__c', 'Answer_Type__c', 'answers.@each.Value__c'),\n    isAtMaxAnswers: function() {\n        return this.get('answers').length === 20;\n    }.property('answers'),\n    elementTypeDidChange: function() {\n        this.focusOnInput();\n    }.observes('Element_Type__c'),\n    actions: {\n        clickDone: function() {\n            var Element_Type__c = this.get('Element_Type__c')\n                , Answer_Type__c = this.get('Answer_Type__c')\n                , answers = this.get('answers')\n                , parentController = this.get('parentController')\n                , formBuilderController = this.get('controllers.formBuilder')\n                , answersToDelete = this.get('answersToDelete')\n                , maxRichTextLength = this.get('maxRichTextLength')\n                , valid = true;\n\n            this.set('errorMessage', null);\n\n            // parse out the rich text content if it's of that type and empty out non-associated fields.\n            if (Element_Type__c === 'Rich Text') {\n                var richText = $('#' + this.get('componentId')).find('iframe').contents().find('body');\n\n                richText.find('[style]').removeAttr('style');\n                richText.find('[class]').removeAttr('class');\n\n                var richTextContent = richText.html();\n\n                // Verify rich text length\n\n                if (richTextContent.length > maxRichTextLength) {\n                    this.set('errorMessage', labels.pleaseReduceTheAmountOfContent);\n                    valid = false;\n                } else {\n                    this.setProperties({\n                        Rich_Text_Content__c: richText.html(),\n                        Text__c: null\n                    });\n                }\n            } else {\n                this.set('Rich_Text_Content__c', null);\n            }\n\n            if (valid !== false) {\n                // add any answers marked to delete to the deletedAnswerChoices array\n                if (!Ember.isEmpty(answersToDelete)) {\n                    formBuilderController.get('deletedAnswerChoices').addObjects(answersToDelete);\n                }\n\n                // clear out answer choices if we're hitting 'Done' on a non-radio/checkbox type.\n                if (Element_Type__c !== 'Question' || (Answer_Type__c !== 'Radio Buttons' && Answer_Type__c !== 'Checkboxes')) {\n                    formBuilderController.get('deletedAnswerChoices').addObjects(answers.getEach('Id')).compact();\n\n                    this.setProperties({\n                        Answer_Type__c: Element_Type__c !== 'Question' ? null : Answer_Type__c,\n                        answers: [Ember.Object.create({\n                            eId: EID++,\n                            formElementEId: this.get('eId'),\n                            Value__c: null,\n                            Score__c: 0,\n                            Disqualify__c: false\n                        })]\n                    });\n                }\n\n                // clear out any answers that were left empty. If a user blanked out a saved answer, consider that deleted.\n                if (Element_Type__c === 'Question' && (Answer_Type__c === 'Radio Buttons' || Answer_Type__c === 'Checkboxes')) {\n                    var emptyAnswers = this.get('answers').filter(function(a) { \n                        return Ember.isEmpty(a.Value__c);\n                    });\n                    formBuilderController.get('deletedAnswerChoices').addObjects(emptyAnswers.getEach('Id'));\n                    this.get('answers').removeObjects(emptyAnswers);\n                }\n\n                this.setProperties({\n                    isEditing: false,\n                    isNew: false\n                });\n            }\n        },\n        clickCancel: function() {\n            var tempObject = this.get('parentController.tempObject');\n\n            // clear out any answers set to be deleted\n            this.get('answersToDelete').clear();\n\n            if (this.get('isNew') === true) {\n                this.deleteMe();    \n            } else if (this.get('isEditing') === true && this.get('isLast') !== true) {\n                this.set('isEditing', false);\n\n                if (tempObject.Element_Type__c === 'Question' && \n                        (tempObject.Answer_Type__c === 'Radio Buttons' || tempObject.Answer_Type__c === 'Checkboxes')) {\n                    var tempAnswers = [];\n\n                    // When restoring the original object on cancel, make sure to turn answers into ember objects.\n                    tempObject.answers.forEach(function(a) {\n                        tempAnswers.push(Ember.Object.create(a));\n                    });\n\n                    tempObject.answers = tempAnswers;\n                }\n\n                // Restore object to what it was before edit.\n                this.setProperties(tempObject);\n            }\n        },\n        clickNew: function() {\n            if (!this.get('isInEditMode')) {\n                var formBuilderController = this.get('controllers.formBuilder')\n                    , formElements = this.get('parentController').get('model')\n                    , formElementEId = EID++\n                    , currentSection = this.get('currentSection')\n                    , sequenceProperty = 'Sequence_Number__c'\n                    , sequenceNumber = this.get(sequenceProperty)\n                    , selectedHiringModel = formBuilderController.get('selectedHiringModel')\n                    , selectedGeography = formBuilderController.get('selectedGeography');\n\n                formElements.forEach(function(fe, i) {\n                    if (fe.get(sequenceProperty) >= sequenceNumber) {\n                        fe.incrementProperty(sequenceProperty);\n                    }\n                });\n\n                formElements.addObject(Ember.Object.create({\n                    eId: formElementEId,\n                    isNew: true,\n                    isEditing: true,\n                    Requisition__c : isOnJobSpecific === true ? requisitionId : null,\n                    Sequence_Number__c: sequenceNumber,\n                    Element_Type__c: 'Question',\n                    Answer_Type__c: 'Radio Buttons',\n                    Text__c: null,\n                    Section__c: currentSection,\n                    Geography__c: currentSection === 'Legal' ? selectedGeography : null,\n                    Hiring_Model__c: currentSection === 'General' ? selectedHiringModel : null,\n                    Source_Position__c: typeof positionId !== 'undefined' ? positionId : null,\n                    Original__c: isOnJobSpecific === true ? true : false,\n                    answers: [Ember.Object.create({\n                        eId: EID++,\n                        formElementEId: formElementEId,\n                        Value__c: null,\n                        Score__c: 0,\n                        Disqualify__c: false\n                    })]\n                }));\n\n                formBuilderController.notifyPropertyChange('formElements');\n\n                this.scrollToElement('.edit-this');\n                this.focusOnInput();\n            }\n        },\n        clickEdit: function() {\n            var currentState = this.get('model');\n            var tempObject = {};\n            // Create a copy of the form element\n            tempObject = JSON.parse(JSON.stringify(currentState));\n\n            this.get('parentController').set('tempObject', tempObject);\n            this.set('isEditing', true);\n            this.scrollToElement('.edit-this');\n            this.focusOnInput();\n        },\n        clickMoveUp: function() {\n            var currentSequenceNumber = this.get('Sequence_Number__c');\n\n            this.send('swapFormElements', currentSequenceNumber, currentSequenceNumber - 1);\n            this.scrollToElement('#' + this.get('divId'), -30, true);\n        },\n        clickMoveDown: function() {\n            var currentSequenceNumber = this.get('Sequence_Number__c');            \n\n            this.send('swapFormElements', currentSequenceNumber, currentSequenceNumber + 1);\n            this.scrollToElement('#' + this.get('divId'), -30, true);\n        },\n        clickDelete: function() {\n            this.set('shouldConfirmDelete', true);\n        },\n        clickConfirmDelete: function() {\n            this.deleteMe();\n        },\n        clickCancelDelete: function() {\n            this.set('shouldConfirmDelete', false);\n        },\n\n        // answer specific actions\n        clickAddAnswer: function() {\n            if (!this.get('isAtMaxAnswers')) {\n                this.get('answers').addObject(Ember.Object.create({\n                    eId: EID++,\n                    formElementEId: this.get('eId'),\n                    Value__c: null,\n                    Score__c: 0,\n                    Disqualify__c: false\n                }));\n                this.notifyPropertyChange('answers');\n\n                Ember.run.scheduleOnce('afterRender', this, function() {\n                    $('.answerInput:last').focus();\n                });\n            }\n        }\n    },\n\n    focusOnInput: function() {\n        Ember.run.scheduleOnce('afterRender', this, function() {\n            $('.edit-this').find('.elementInput').focus();\n        });\n    },\n    deleteMe: function() {\n        var formBuilderController = this.get('controllers.formBuilder')\n            , formElements = this.get('parentController').get('model')\n            , sequenceProperty = 'Sequence_Number__c'  \n            , sequenceNumber = this.get(sequenceProperty);\n\n        if (!Ember.isNone(this.get('Id'))) {\n            formBuilderController.get('deletedFormElements').addObject(this.get('Id'));\n        }\n\n        this.set('isEditing', false);\n        formElements.removeObject(this.get('model'));\n\n        formElements.forEach(function(fe, i) {\n            var feSequenceNumber = fe.get(sequenceProperty);\n            if (!Ember.isEmpty(feSequenceNumber) && feSequenceNumber > sequenceNumber) {\n                fe.decrementProperty(sequenceProperty);\n            }\n        });\n\n        if (isOnJobSpecific !== true) {\n            formBuilderController.notifyPropertyChange('general');\n            formBuilderController.notifyPropertyChange('legal');\n        }\n    },\n    scrollToElement: function(elementQuery, paddingAmount, usePrev) {\n        Ember.run.scheduleOnce('afterRender', this, function() {\n            var element = usePrev === true ? $(elementQuery).prev('div') : $(elementQuery);\n\n            if ($(element).length > 0) {\n                var scrollToPosition = $(element).offset().top;\n\n                if (paddingAmount) {\n                    scrollToPosition += paddingAmount;\n                }\n\n                $('html, body').animate({\n                    scrollTop: scrollToPosition\n                }, 300);\n            }\n        });\n    }\n});\n\nApp.AnswerMixin = Ember.Mixin.create({\n    needs: ['formBuilder'],\n    isThumbsDown: Ember.computed.equal('Score__c', -1),\n    isThumbsUp: Ember.computed.equal('Score__c', 1),\n    isDisqualify: Ember.computed.equal('Disqualify__c', true),\n    actions: {\n        clickVote: function(vote) {\n            var currentScore = this.get('Score__c')\n                , currentDisqualify = this.get('Disqualify__c');\n\n            if (vote === 'upVote') {\n                this.setProperties({\n                    Score__c: currentScore === 1 ? 0 : 1,\n                    Disqualify__c: false\n                });\n            } else if (vote === 'downVote') {\n                this.setProperties({\n                    Score__c: currentScore === -1 ? 0 : -1,\n                    Disqualify__c: false\n                });\n            } else if (vote === 'disqualify') {\n                this.set('Score__c', 0);\n                this.toggleProperty('Disqualify__c');\n            }\n        },\n        clickDelete: function() {\n            var parentController = this.get('parentController');\n\n            parentController.get('answers').removeObject(this.get('model'));\n\n            if(!Ember.isNone(this.get('Id'))) {\n                parentController.get('answersToDelete').addObject(this.get('Id'));\n            }\n            parentController.notifyPropertyChange('answers');\n        }\n    }\n});\n\n})();//@ sourceURL=js/formBuilderMixins.js")

eval("(function() {\n\n// Add a labels property to every controller so that we don't have to access the global scope (which was deprecated).\nEmber.ControllerMixin.reopen({\n    labels: labels\n});\n\n// Attribute bindings for QA locators so we can easily add them to ember markup.\nEmber.View.reopen({\n    attributeBindings: ['data-dev', 'data-qa', 'data-qa-label', 'data-qa-button', 'data-qa-input', \n                        'data-qa-link', 'data-qa-pane', 'data-qa-select', 'da-qa-modal', 'data-qa-alert',\n                        'data-qa-container'],\n    didInsertElement : function(){\n        this._super();\n\n        Ember.run.scheduleOnce('afterRender', this, this.initJUI);   \n    },\n    initJUI: function() {\n        // Initialize tooltips if they exist. This might actually be expensive since it's run every time a new view is added. Will refactor.\n        /*if ($('[data-toggle=\"tooltip\"]').length > 0) {\n            $('body').tooltip({\n                selector: '[data-toggle=tooltip]'\n            });\n        }*/\n        this.afterRenderEvent();\n    },\n    afterRenderEvent : function() {\n        // implement this hook in your own subclasses and run your jQuery logic there\n    }\n});\n\n})();//@ sourceURL=js/emberBase.js")